---
title:  "Création d'une image Linux personnalisée"
date:   2025-07-30
categories: pratique configuration
toc: true
code_bloc_prefix: true
---

## Objectif
Notre objectif est de créer un fichier image (.iso) bootable, de son environnement de travail Linux.
Cela permettrait, à la manière d'un conteneur, d'uniformiser l'installation d'une distribution Linux personnalisée, par l'ajout d'applications, l'ajustement de paramètres ou la création de fichiers particuliers, sur de multiples postes de travail. Une autre utilisation possible serait d'avoir une distribution modifiée semi-éphémère simple à déployer, un peu à la manière de Tails.
Même si elle s'en rapproche, l'idée n'est pas de conteneuriser l'environnement de travail comme pourrait le faire exegol par exemple, mais d'avoir accès à un OS complet, paramétré sur mesure.

## Environnement
Les commandes qui vont suivre sont adaptées pour un Parrot OS, une distribution basée sur Debian. Certaines différences de résultats pourraient apparaître sur des distributions Debian, Ubuntu ou d'autres encore.

## Préparation de l'environnement
Avant de figer le système dans une image iso, il faut le préparer en incluant tous les fichiers, toutes les configurations et autres spécificités qu'on veut lui apporter. En plus de ça, il est recommandé de mettre à jour son système avec les commandes suivantes.
```bash
sudo apt update && sudo apt upgrade
sudo apt clean
sudo apt autoremove
```
{: .nolineno .prompt .prompt-user-vm }

Optionnellement, avant de cloner le système de fichiers, il est possible de supprimer l'historique des commandes.
```bash
history -c
```
{: .nolineno .prompt .prompt-user-vm }

## Copie du système
Commençons par créer le système de fichier à inscrire dans l'image à partir de notre système actuel. Pour cela, nous allons cloner un système de fichier minimal, en y ajoutant nos fichiers personnalisés, ainsi que les répertoires systèmes dynamiques, virtuels ou temporaires, vides. En effet, leur contenu ne serait pas utiles et prendraient de la place, mais le répertoire est nécessaire lors du boot pour y monter des fichiers.
Nous créons pour cela un répertoire de travail et utilisons `rsync` pour la création du système de fichiers personnalisé.
```bash
mkdir -p custom-root
sudo rsync -aAX --exclude={"/boot/*","/proc/*","/sys/*","/dev/*","/run/*","/tmp/*","/mnt/*","/media/*","/var/tmp/*","/var/cache/*","/var/lib/containers","/home/$USER/custom-root/*"} / ./custom-root
```
{: .nolineno .prompt .prompt-user-vm }

> Notons l'exclusion du dossier de travail, pour éviter de l'inclusion récursive.

> `mksquashfs` ne peut pas être directement utilisé en excluant le contenu des répertoires car, étant vides, ils ne seraient pas ajoutés lors de la compression.

Dans le système ainsi créé, vérifions que seul le système de fichier racine sera monté automatiquement à l'initialisation du système.
```bash
sudo nano custom-root/etc/fstab
```
{: .nolineno .prompt .prompt-user-vm }

Et commenter toutes les lignes ne concernant pas le point de montage racine (`mount point` `/`).

S'il n'a pas encore été défini, il peut être utile de créer un mot de passe pour l'utilisateur `root` dans ce système de fichiers en cas d'accès au rescue mode.
```bash
sudo chroot custom-root
#passwd root
#exit
```
{: .nolineno .prompt .prompt-user-vm }

## Compression du système
Une fois le système préparé, nous allons le compresser en un fichier `filesystem.squashfs`, en utilisant `mksquashfs`.
Commençons par créer un répertoire de travail pour cela.
```bash
mkdir -p custom-iso/iso/{live,isolinux}
cd custom-iso
```
{: .nolineno .prompt .prompt-user-vm }

Puis compressons le système contenu dans `custom-root`.
```bash
sudo mksquashfs ../custom-root ./iso/live/filesystem.squashfs
```
{: .nolineno .prompt .prompt-user-vm-custom-iso }

## Créer l'ISO
Maintenant que notre système de fichiers est compressé, ajoutons le noyau et l'initrd dans notre nouvelle arborescence.
```bash
sudo cp /boot/vmlinuz-$(uname -r) ./iso/live/vmlinuz
sudo cp /boot/initrd.img-$(uname -r) ./iso/live/initrd
```
{: .nolineno .prompt .prompt-user-vm-custom-iso }

Puis le boot loader et ses fichiers complémentaires.
```bash
cp /usr/lib/ISOLINUX/isolinux.bin ./iso/isolinux/
cp /usr/lib/syslinux/modules/bios/* ./iso/isolinux/
```
{: .nolineno .prompt .prompt-user-vm-custom-iso }

Ensuite, il faut ajouter le fichier de configuration `./iso/isolinux/isolinux.cfg` qui renseigne les différentes options du menu du boot. Le fichier présenté est un fichier minimal mais opérationnel.
```bash
echo -e "UI vesamenu.c32\nDEFAULT live\nPROMPT 0\nTIMEOUT 50\n\nLABEL live\n  MENU LABEL Boot Custom OS\n  KERNEL /live/vmlinuz\n  APPEND initrd=/live/initrd boot=live" > ./iso/isolinux/isolinux.cfg
```
{: .nolineno .prompt .prompt-user-vm-custom-iso }

> `quiet splash` peut être ajouté à la ligne `APPEND` pour masquer les messages de debug lors du boot du système.

Maintenant que notre système est complété, il ne reste plus qu'à le transformer en un fichier iso via `xorriso`.
```bash
sudo xorriso -as mkisofs -iso-level 3 -o custom_os.iso -full-iso9660-filenames -volid "CUSTOM_OS" -isohybrid-mbr /usr/lib/ISOLINUX/isohdpfx.bin -c isolinux/boot.cat -b isolinux/isolinux.bin -no-emul-boot -boot-load-size 4 -boot-info-table ./iso
```
{: .nolineno .prompt .prompt-user-vm-custom-iso }

> Les paramètres de la commande ne créent pas de compatibilité UEFI ici.

## Test
Nous pouvons tester notre image directement depuis notre système pour s'assurer qu'il fonctionne avant de le déployer ou de le transférer sur un autre système.
```bash
qemu-system-x86_64 -m 2048 -cdrom custom_os.iso
```
{: .nolineno .prompt .prompt-user-vm-custom-iso }

> Dans ce cas, certaines alertes peuvent apparaître, comme l'émulation n'embarque pas certains paramètres. Les erreurs peuvent concerner les Guest Additions ou les applets du panneau XFCE par exemple.

![erreur_VBoxClient.png](/assets/img/Image_erreur_VBoxClient.png)

Illustration 1 : Erreur liée à l'absence des Guest Additions
{: .legende }

![erreur_applet.png](/assets/img/Image_erreur_applet.png)

Illustration 2 : Erreur liée aux applets du panneau XFCE
{: .legende }